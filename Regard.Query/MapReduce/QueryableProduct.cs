using System;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using Regard.Query.Api;
using Regard.Query.Serializable;

namespace Regard.Query.MapReduce
{
    /// <summary>
    /// Represents a product that can be queried using the map/reduce system
    /// </summary>
    class QueryableProduct : IQueryableProduct, IUserAdmin
    {
        /// <summary>
        /// The key/value store dedicated to this product
        /// </summary>
        private readonly IKeyValueStore m_ProductDataStore;

        /// <summary>
        /// The data store where information about users is stored
        /// </summary>
        private readonly IKeyValueStore m_UserDataStore;

        /// <summary>
        /// The data store where information about queries is stored
        /// </summary>
        private readonly IKeyValueStore m_QueryDataStore;

        /// <summary>
        /// The name of the node that this query represents
        /// </summary>
        private readonly string m_NodeName;

        public QueryableProduct(IKeyValueStore productDataStore, string nodeName)
        {
            if (productDataStore == null) throw new ArgumentNullException("productDataStore");

            m_NodeName          = nodeName;
            m_ProductDataStore  = productDataStore;
            m_UserDataStore     = m_ProductDataStore.ChildStore(new JArray("users"));
            m_QueryDataStore    = m_ProductDataStore.ChildStore(new JArray("queries"));
        }

        /// <summary>
        /// Creates a new query builder for this product
        /// </summary>
        public IQueryBuilder CreateQueryBuilder()
        {
            return new SerializableQueryBuilder(null);
        }

        /// <summary>
        /// Registers a query built by the query builder as active for this product
        /// </summary>
        /// <param name="queryName">A name for this query. If the query already exists then </param>
        /// <param name="query">A query generated by the query builder for this product (ie, the query builder created by <see cref="CreateQueryBuilder"></see>)</param>
        public async Task RegisterQuery(string queryName, IRegardQuery query)
        {
            var serializable = query as SerializableQuery;
            if (serializable == null) throw new ArgumentException("Invalid query object", "query");

            // Each running node should have a unique name
            JArray nodeQueryKey = new JArray(m_NodeName);

            // Generate data for this particular query
            JObject queryData = new JObject();

            // The 'when' field is used in case two queries wind up with the same name but created on separate nodes
            queryData["When"]   = (DateTime.UtcNow - DateTime.MinValue).TotalSeconds;
            queryData["Query"]  = serializable.ToJson();

            // The queries are all stored in a single data object
            // There is one data object per node to support scaling (no node needs to worry about overwriting another's data)
            JObject existingQuery = await m_QueryDataStore.GetValue(nodeQueryKey);
            JObject queryList;

            if (existingQuery == null)
            {
                existingQuery   = new JObject();
                queryList       = new JObject();
            }
            else
            {
                JToken queryListToken;
                if (existingQuery.TryGetValue("Queries", out queryListToken))
                {
                    queryList = queryListToken.Value<JObject>();
                }
                else
                {
                    queryList = new JObject();
                }
            }

            // Add to this query
            queryList[queryName] = queryData;

            // Store this item
            existingQuery["Queries"] = queryList;
            await m_QueryDataStore.SetValue(nodeQueryKey, existingQuery);
        }

        /// <summary>
        /// Runs the query with the specified name against the database
        /// </summary>
        public Task<IResultEnumerator<QueryResultLine>> RunQuery(string queryName)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Retrieves the object that can administer the users of this project
        /// </summary>
        public IUserAdmin Users { get { return this; } }

        /// <summary>
        /// Marks a specific user ID as being opted in to data collection for a specific product
        /// </summary>
        public async Task OptIn(Guid userId)
        {
            JObject userData = new JObject();

            userData["OptInState"] = "opt-in";

            await m_UserDataStore.SetValue(new JArray(userId.ToString()), userData);
        }

        /// <summary>
        /// Marks a specific user ID as being opted out from data collection for a specific product
        /// </summary>
        /// <remarks>
        /// This only opts out for future data collection. Any existing data will be retained.
        /// </remarks>
        public async Task OptOut(Guid userId)
        {
            JObject userData = new JObject();

            userData["OptInState"] = "opt-out";

            await m_UserDataStore.SetValue(new JArray(userId.ToString()), userData);
        }
    }
}
