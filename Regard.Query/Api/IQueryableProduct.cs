using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;

namespace Regard.Query.Api
{
    /// <summary>
    /// Represents a product that can be queried
    /// </summary>
    public interface IQueryableProduct
    {
        /// <summary>
        /// Creates a new query builder for this product
        /// </summary>
        IQueryBuilder CreateQueryBuilder();

        /// <summary>
        /// Registers a query built by the query builder as active for this product
        /// </summary>
        /// <param name="queryName">A name for this query. If the query already exists then </param>
        /// <param name="query">A query generated by the query builder for this product (ie, the query builder created by <see cref="CreateQueryBuilder"></see>)</param>
        Task RegisterQuery(string queryName, IRegardQuery query);

        /// <summary>
        /// Runs the query with the specified name against the database
        /// </summary>
        Task<IResultEnumerator<QueryResultLine>> RunQuery(string queryName);

        /// <summary>
        /// Given an indexed query, retuns the values matching the specified index(es)
        /// </summary>
        /// <remarks>
        /// For example, if a query is created as 'IndexedBy("user-id")', then the user ID can be specified in the indexValues parameters to get the
        /// query as it would appear only to that user.
        /// </remarks>
        Task<IResultEnumerator<QueryResultLine>> RunIndexedQuery(string queryName, params string[] indexValues);

        /// <summary>
        /// Ensures that the actualised data and indexes are up to date for this product
        /// </summary>
        /// <remarks>
        /// When using the map/reduce query engine, it can take a while to run queries that haven't been accessed recently and
        /// that have many events. This task makes sure that they are all up to date: it's a good idea to call this once
        /// every 5000 events or so.
        /// </remarks>
        Task UpdateAllQueries();

        /// <summary>
        /// Retrieves all of the raw events associated with a particular user ID
        /// </summary>
        /// <remarks>
        /// This is intended to support the user page: the results of running this query are meant to be displayed only to that user.
        /// <para/>
        /// One thought about a future version is that we might only want to store aggregate data, which would make this call redundant as
        /// we would no longer store data for a specific user.
        /// </remarks>
        Task<IPagedResultEnumerator<JObject>> RetrieveEventsForUser(Guid userId, string pageToken); 

        /// <summary>
        /// Retrieves the object that can administer the users of this project
        /// </summary>
        IUserAdmin Users { get; }
    }
}
