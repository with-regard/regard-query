using System;
using System.Data.SqlClient;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Regard.Query.Api;
using Regard.Query.Serializable;

namespace Regard.Query.Sql
{
    /// <summary>
    /// A product that can be queried using the SQL data store
    /// </summary>
    public class SqlQueryableProduct : IQueryableProduct
    {
        /// <summary>
        /// The connection that this should use
        /// </summary>
        private readonly SqlConnection m_Connection;

        /// <summary>
        /// The product ID represented by this object
        /// </summary>
        private readonly long m_ProductId;

        private const string c_InsertQuery  = "DELETE FROM [RegisteredQuery] WHERE [ProductId] = @productId AND [QueryName] = @queryName ; \n"
                                            + "INSERT INTO [RegisteredQuery] ([ProductId], [QueryName], [QueryDataJson]) VALUES (@productId, @queryName, @queryData) ; \n";

        private const string c_GetQuery     = "SELECT [QueryDataJson] FROM [RegisteredQuery] WHERE [ProductId] = @productId AND [QueryName] = @queryName";

        public SqlQueryableProduct(SqlConnection connection, long productId)
        {
            m_Connection = connection;
            m_ProductId = productId;
        }

        /// <summary>
        /// Creates a new query builder for this product
        /// </summary>
        public IQueryBuilder CreateQueryBuilder()
        {
            // Just use a serializable query builder
            return new SerializableQueryBuilder(null);
        }

        /// <summary>
        /// Registers a query built by the query builder as active for this product
        /// </summary>
        /// <param name="queryName">A name for this query. If the query already exists then </param>
        /// <param name="query">A query generated by the query builder for this product (ie, the query builder created by <see cref="IQueryableProduct.CreateQueryBuilder"></see>)</param>
        public async Task RegisterQuery(string queryName, IRegardQuery query)
        {
            // Need a serializable query
            if (query == null) throw new ArgumentNullException("query");

            SerializableQuery serialQuery = query as SerializableQuery;
            if (serialQuery == null) throw new InvalidOperationException("Query not created by this object");

            // Sanity check the query name
            if (string.IsNullOrEmpty("queryName"))  throw new ArgumentException("Query must have a name", "queryName");
            if (queryName.Length > 200)             throw new ArgumentException("Query name cannot be longer than 200 characters", "queryName");

            // Store in the database
            using (var transaction = m_Connection.BeginTransaction())
            {
                // Format the query as JSON
                string asJson = serialQuery.ToJson().ToString(Formatting.None);

                // Prepare the query
                var insertQueryCommand = new SqlCommand(c_InsertQuery, m_Connection, transaction);
                insertQueryCommand.Parameters.AddWithValue("@productId", m_ProductId);
                insertQueryCommand.Parameters.AddWithValue("@queryName", queryName);
                insertQueryCommand.Parameters.AddWithValue("@queryData", asJson);

                await insertQueryCommand.ExecuteNonQueryAsync();

                // Done
                transaction.Commit();
            }
        }

        /// <summary>
        /// Runs the query with the specified name against the database
        /// </summary>
        public async Task<IResultEnumerator<QueryResultLine>> RunQuery(string queryName)
        {
            // Get the query
            var getTheQuery = new SqlCommand(c_GetQuery, m_Connection);

            getTheQuery.Parameters.AddWithValue("@productId", m_ProductId);
            getTheQuery.Parameters.AddWithValue("@queryName", queryName);

            SqlQuery decoded;
            using (var reader = await getTheQuery.ExecuteReaderAsync())
            {
                // Should be a single row in the result
                bool foundQuery = await reader.ReadAsync();

                if (!foundQuery)
                {
                    // TODO: report this without an exception somehow? This isn't really exceptional behaviour
                    throw new InvalidOperationException("Query '" + queryName + "' not found");
                }

                // Rebuild the query
                SqlQueryBuilder queryBuilder    = new SqlQueryBuilder(m_Connection, m_ProductId, WellKnownUserIdentifier.ProductDeveloper);
                string          queryJson       = reader.GetFieldValue<string>(0);
                JObject         queryDecoded    = JObject.Parse(queryJson);

                decoded = (SqlQuery) queryBuilder.FromJson(queryDecoded);
            }

            // Run the query we decoded
            return await decoded.RunQuery();
        }
    }
}
