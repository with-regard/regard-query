using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Text;
using System.Threading.Tasks;
using Regard.Query.Api;

namespace Regard.Query.Sql
{
    /// <summary>
    /// Representation of a query run against a SQL database
    /// </summary>
    public class SqlQuery : IRegardQuery
    {
        /// <summary>
        /// The elements to this query
        /// </summary>
        private readonly List<SqlQueryElement> m_Elements = new List<SqlQueryElement>(); 

        /// <summary>
        /// Creates the 'all events' SQL query
        /// </summary>
        internal SqlQuery(SqlQueryBuilder builder)
        {
            Builder = builder;
        }

        /// <summary>
        /// Creates a SQL query limited by a new element
        /// </summary>
        internal SqlQuery(SqlQuery query, SqlQueryElement newElement)
        {
            Builder = query.Builder;
            m_Elements = new List<SqlQueryElement>(query.m_Elements);

            if (newElement != null)
            {
                m_Elements.Add(newElement);
            }
        }

        /// <summary>
        /// The object that built this query (and which can be used to refine it)
        /// </summary>
        public SqlQueryBuilder Builder
        {
            get; private set;
        }

        /// <summary>
        /// The object that built this query (and which can be used to refine it)
        /// </summary>
        IQueryBuilder IRegardQuery.Builder { get { return Builder; } }

        /// <summary>
        /// Ensure that all the clauses in the query have assigned parameter names
        /// </summary>
        private void GenerateParameterNames()
        {
            int paramNum = 1;

            // Assign parameter names to each element...
            foreach (var element in m_Elements)
            {
                // The where clause is what generates the parameters
                if (element.Wheres != null)
                {
                    foreach (var whereClause in element.Wheres)
                    {
                        // Assign a name
                        if (whereClause.ParameterName == null)
                        {
                            // TODO: if we start using these queries in more complicated circumstances, this could result in the same parameter name being assigned to two clauses
                            whereClause.ParameterName = @"@P" + paramNum;
                            ++paramNum;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Generates the SQL query
        /// </summary>
        /// <remarks>
        /// The query generated by this function will use '?' in place of values that need to be substituted in later (ie, the 'WHERE' values)
        /// </remarks>
        public string GenerateQuery()
        {
            // Ensure that all the parameter names are generated
            GenerateParameterNames();

            // We build up the 4 parts of the query seperately
            StringBuilder selectPart    = new StringBuilder();
            StringBuilder fromPart      = new StringBuilder();
            StringBuilder wherePart     = new StringBuilder();
            StringBuilder groupPart     = new StringBuilder();

            // We always count the number of events
            selectPart.Append("COUNT(DISTINCT [epv1].EventId)");

            // Restrict to events from the specified product
            fromPart.Append("[Event] AS event INNER JOIN [EventPropertyValues] AS [epv1] ON [epv1].[EventId] = [event].[Id]");
            fromPart.Append("\nINNER JOIN [EventProperty] AS [ep1] ON [ep1].[Id] = [epv1].[PropertyId]");
            fromPart.Append("\nINNER JOIN [Session] AS [session] ON [session].[ShortSessionId] = [event].[ShortSessionId]");
            fromPart.Append("\nINNER JOIN [OptInUser] AS [user] ON ([user].[ShortUserId] = [session].[ShortUserId] AND [user].[ProductId] = @productId)");

            wherePart.Append("[session].[ProductId] = @productId");

            if (Builder.UserId.Equals(WellKnownUserIdentifier.ProductDeveloper))
            { 
                // Restrict to users who are opted-in
                fromPart.Append("\nINNER JOIN [OptInState] AS [optin] ON [optin].[StateId] = [user].[OptInStateId]");

                wherePart.Append("\nAND [optin].[Name] = 'ShareWithDeveloper'");
            }
            else
            {
                // Restrict to the specified user ID
                wherePart.Append("\nAND [user].[FullUserId] = @userId");
            }

            // Each element forms a new inner join
            for (int tableId = 0; tableId < m_Elements.Count; ++tableId)
            {
                // Get the table name (here's why overloading '+' to mean different things is a bad language design descision)
                var     element                 = m_Elements[tableId];
                string  propertyTableName       = "ep" + (tableId + 1);
                string  propertyValueTableName  = "epv" + (tableId + 1);

                // Add to the from part
                if (tableId == 0)
                {
                    // Start with all the events from the product
                }
                else
                {
                    fromPart.Append("\nINNER JOIN [EventPropertyValues] AS [" + propertyValueTableName + "] ON [epv1].[EventId] = [" + propertyValueTableName + "].[EventId]");
                    fromPart.Append("\nINNER JOIN [EventProperty] AS [" + propertyTableName + "] ON [" + propertyValueTableName + "].[PropertyId] = [" + propertyTableName + "].[Id]");
                }

                // Build up the select part as needed
                if (element.Summarisation != null)
                {
                    foreach (var sum in element.Summarisation)
                    {
                        if (selectPart.Length > 0)
                        {
                            selectPart.Append(", ");
                        }
                        selectPart.Append(sum.ToQuery(propertyTableName, propertyValueTableName));
                    }
                }

                // Then the WHERE part
                if (element.Wheres != null)
                {
                    if (wherePart.Length > 0)
                    {
                        wherePart.Append("\n");
                    }
                    foreach (var where in element.Wheres)
                    {
                        if (wherePart.Length > 0)
                        {
                            wherePart.Append(" AND ");
                        }
                        wherePart.Append(where.ToQuery(propertyTableName, propertyValueTableName));
                    }
                }

                // Finally, the group part
                if (element.GroupBy != null)
                {
                    foreach (var group in element.GroupBy)
                    {
                        if (groupPart.Length > 0)
                        {
                            groupPart.Append(", ");
                        }

                        if (group == "PropertyName")
                        {
                            groupPart.Append("[" + propertyTableName + "].[Name]");
                        }
                        else
                        {
                            groupPart.Append("[" + propertyValueTableName + "].[" + group + "]");
                        }
                    }
                }
            }

            // Build up the final query
            StringBuilder finalQuery = new StringBuilder();

            finalQuery.Append("SELECT ");
            finalQuery.Append(selectPart);
            finalQuery.Append('\n');
            finalQuery.Append("FROM ");
            finalQuery.Append(fromPart);
            finalQuery.Append('\n');

            if (wherePart.Length > 0)
            {
                finalQuery.Append("WHERE ");
                finalQuery.Append(wherePart);
                finalQuery.Append('\n');
            }

            if (groupPart.Length > 0)
            {
                finalQuery.Append("GROUP BY ");
                finalQuery.Append(groupPart);
                finalQuery.Append('\n');
            }
            finalQuery.Append(";\n");

            return finalQuery.ToString();
        }

        /// <summary>
        /// Returns the parameters to be substituted for the query
        /// </summary>
        public IEnumerable<SqlSubstitution> GenerateSubstitutions()
        {
            // This is just the where values in order
            foreach (var elem in m_Elements)
            {
                if (elem.Wheres == null) continue;
                foreach (var where in elem.Wheres)
                {
                    yield return new SqlSubstitution(where.ParameterName, where.FieldValue);
                }
            }
        }

        /// <summary>
        /// Runs this query against the database
        /// </summary>
        public Task<IResultEnumerator<QueryResultLine>> RunQuery()
        {
            return RunQuery(Builder.Connection);
        }

        /// <summary>
        /// Runs this query against the database
        /// </summary>
        public async Task<IResultEnumerator<QueryResultLine>> RunQuery(SqlConnection connection)
        {
            // Sanity check
            if (connection == null)
            {
                // Can't execute a query if there's no connection
                throw new ArgumentNullException("connection");
            }

            // Ensure that the parameter names exist
            GenerateParameterNames();

            // Create the query command
            var queryText       = GenerateQuery();
            var queryCommand    = new SqlCommand(queryText, connection);

            // Substitute parameters
            queryCommand.Parameters.AddWithValue("@productId", Builder.ProductId);
            queryCommand.Parameters.AddWithValue("@userId", Builder.UserId);
            foreach (var param in GenerateSubstitutions())
            {
                queryCommand.Parameters.AddWithValue(param.Name, param.Value);
            }

            // Execute the command
            var queryReader = await queryCommand.ExecuteReaderAsync();
            bool finished = false;

            // Format as query result lines
            var result = new GenericQueryEnumerator(async () =>
                {
                    if (finished)
                    {
                        // If we already finished, just return any amount of nulls
                        return null;
                    }

                    // Read the next item
                    var readNext = await queryReader.ReadAsync();

                    if (!readNext)
                    {
                        // Finished with the query reader
                        queryReader.Dispose();

                        // Reached the end
                        finished = true;
                        return null;
                    }

                    // Get the event count for this line (always the first field)
                    long eventCount;
                    Type firstFieldType = queryReader.GetFieldType(0);

                    if (firstFieldType == typeof (int))
                    {
                        eventCount = await queryReader.GetFieldValueAsync<int>(0);
                    }
                    else
                    {
                        eventCount = await queryReader.GetFieldValueAsync<long>(0);
                    }

                    // Read the user-generated field values, and turn them into result columns
                    List<QueryResultColumn> columns = new List<QueryResultColumn>();

                    // Each summarisation function produces one column. The first column is the count, so we start from the second.
                    int fieldCount  = queryReader.FieldCount;
                    int fieldId     = 1;

                    foreach (var elem in m_Elements)
                    {
                        // Ignore elements that don't generate any fields
                        if (elem.Summarisation == null)
                        {
                            continue;
                        }

                        // One field per named summarisation function
                        foreach (var summarisation in elem.Summarisation)
                        {
                            // Handle the (buggy) case where there are more summarisations than fields
                            if (fieldId >= fieldCount)
                            {
                                break;
                            }

                            // Read the value if this is a summarisation field
                            if (!string.IsNullOrEmpty(summarisation.FieldName))
                            {
                                string  stringValue = "";
                                long    intValue    = 0;

                                // Get the type of this field
                                var fieldType = queryReader.GetFieldType(fieldId);

                                if (fieldType == null)
                                {
                                }
                                else if (fieldType == typeof (int))
                                {
                                    intValue    = await queryReader.GetFieldValueAsync<int>(fieldId);
                                    stringValue = intValue.ToString();
                                }
                                else if (fieldType == typeof(long))
                                {
                                    intValue    = await queryReader.GetFieldValueAsync<long>(fieldId);
                                    stringValue = intValue.ToString();
                                }
                                else if (fieldType == typeof(string))
                                {
                                    stringValue = await queryReader.GetFieldValueAsync<string>(fieldId);
                                }
                                else if (fieldType == typeof(double))
                                {
                                    var doubleValue = await queryReader.GetFieldValueAsync<double>(fieldId);
                                    stringValue = doubleValue.ToString();
                                }

                                // Store this column
                                columns.Add(new QueryResultColumn
                                    {
                                        Name = summarisation.ResultName,
                                        Value = stringValue
                                    });
                            }

                            // Move on to the next field
                            ++fieldId;
                        }
                    }

                    // Generate the line
                    var newLine = new QueryResultLine(eventCount, columns);
                    return newLine;
                },
                () =>
                {
                    // Dispose of the query reader if we haven't reached the end already
                    if (!finished)
                    {
                        queryReader.Dispose();
                        finished = true;
                    }
                });

            return result;
        }
    }
}
